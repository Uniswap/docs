---
title: Get Started
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Get Started

In the current version of the Uniswap Protocol Fee system, searchers can *permissionlessly* capture value from the system
by receiving assets valued greater than the UNI tokens provided to the system.

The simplest way to interact with the system is calling [`Firepit.release()`](../technical-reference/IReleaser#release) from a wallet

:::note
It is possible to interact with the `Firepit` contract via a custom smart contract to enable:
* slippage / balance checks
* Uniswap v3 Fee [collection](./best-practices.mdx#collect-uniswap-v3-fees)
* Uniswap v2 LP Token [redemptions](./read-asset-balance.mdx#uniswap-v2-pool-protocol-fees)
* UNI token flash loans
:::

## Acquire a sufficient amount of UNI
The `Firepit` contract requires integrators to hold a minimum amount of UNI to call `release()`.
Participants can view the `threshold` by calling [`Firepit.threshold()`](../technical-reference/IResourceManager#threshold)

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
uint256 threshold = IFirepit(address(0x1)).threshold();
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast call 0x1 "threshold()(uint256)" --rpc-url <RPC_URL>
```
</TabItem>
</Tabs>

## Approve the Firepit to spend UNI
Because the `Firepit` contract transfers UNI to `address(0xdead)`, integrating addresses **must first approve** the contract to spend their UNI

:::warning
Integrators should assess the risks of max approving the `Firepit` contract
:::

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984).approve(
    0x1,
    type(uint256).max
);
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast send 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984 \
    "approve(address,uint256)(bool)" \
    --rpc-url <RPC_URL> \
    0x1 \
    115792089237316195423570985008687907853269984665640564039457584007913129639935
```
</TabItem>
</Tabs>

## Read the Nonce

The `Firepit` contract uses a `nonce` as a safety mechanism to avoid malicious front-running. The value is provided to `release(...)` must be equal
to the value in contract storage

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity [solidity]
uint256 nonce = IFirepit(address(0x1)).nonce();
```
</TabItem>
<TabItem value="bash" label="cast">
```bash
cast call 0x1 "nonce()(uint256)" --rpc-url <RPC_URL>
```
</TabItem>
</Tabs>

## Call `Firepit.release()`

Once the value of the assets exceeds the value of the UNI tokens, integrators should call [`Firepit.release()`](../technical-reference/IReleaser#release)

<Tabs>
<TabItem value="solidity" label="solidity">
```solidity
uint256 _nonce = IFirepit(address(0x1)).nonce();

Currency[] memory _assets = new Currency[](3);
_assets[0] = Currency.wrap(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); // USDC
_assets[1] = Currency.wrap(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); // USDT
_assets[2] = Currency.wrap(address(0x0000000000000000000000000000000000000000)); // ETH

IFirepit(address(0x1)).release(_nonce, _assets, 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045);
```
</TabItem>

<TabItem value="bash" label="cast">
```bash
cast send 0x1 "release(uint256,address[],address)" --rpc-url <RPC_URL> \
    <CURRENT_NONCE> <ASSET_ADDRESSES> <RECEIVER_ADDRESS>

# example: release USDC, USDT, and ETH to vitalik.eth
cast send 0x1 "release(uint256,address[],address)" --rpc-url <RPC_URL> \
    0 \
    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,0xdAC17F958D2ee523a2206206994597C13D831ec7,0x0000000000000000000000000000000000000000 \
    0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```
</TabItem>
</Tabs>

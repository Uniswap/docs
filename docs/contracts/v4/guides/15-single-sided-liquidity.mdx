---
title: Single-sided Liquidity
---

In this example we will create a single-side liquidity position a Buy Limit style range order that  swaps token1 for token0 as the market price falls into your defined tick range.

Fetch the current pool price (sqrtPriceX96)

Compute a -5% target price and align it with a usable tick

Calculate the required liquidity using only token1

Approve the correct token and use mint() to create a position

Monitor and fine-tune the amount1Max buffer for slippage tolerance

## Introduction

This guide will cover how single-side liquidity provisioning can be used to execute **Limit Orders** on Uniswap V4 Pools.


This guide will **cover**:

1. Understanding Range Orders
2. Calculating our Tick Range
3. Creating a single-side liquidity position
5. Closing the Limit Order

Before working through this guide, consider checking out the Range Orders [concept page](https://docs.uniswap.org/concepts/protocol/range-orders) to understand how Limit orders can be executed with Uniswap v4.

:::info
This guide is built using the [v4-template repository](https://github.com/uniswapfoundation/v4-template) and utilises the Config and Constants files as imports for contract addresses.
:::

## Understanding Range Orders

If you have read the [Range Order Concept page](../../../../concepts/protocol/range-orders.md), you can skip this section.

Positions on a v4 Pool are always created with a Tick range in which their liquidity is accessible to swaps on the Pool.

If we consider the structure of mint function in the Position Manager contract, that helps mint a new position.

```solidity
function _mint(
    PoolKey calldata poolKey,
    int24 tickLower,
    int24 tickUpper,
    uint256 liquidity,
    uint128 amount0Max,
    uint128 amount1Max,
    address owner,
    bytes calldata hookData
)
```

We see that a position only stores a single `liquidity` value, and a `tickLower` and `tickUpper` value that define the range in which the liquidity of the Position can be utilised for Swaps.
The actual **amount** of `token0` and `token1` that a Pool owes the Position owner is calculated from the parts of the liquidity position that are to the left and right of the current Tick.
Liquidity left of the current Tick is denominated in `token0` and liquidity right of the current Tick is denominated in `token1`.

If a new Position is created and the Tick Range of the position does not include the current Tick of the Pool, only one of the two Tokens in the Pool can be provided.

We will call this a **Single Side Liquidity Position**.

<img src={require('../images/range-order.png').default} alt="RangeOrder" box-shadow="none"/>

When the current Tick of the Pool moves across the Position, the ratio of `token0` and `token1` will change, and ultimately inverse if the current Tick moves out of the position on the other side.

We will utilise this behaviour to provide liquidity with `token1` and withdraw the position when it has been converted to `token0`.

## Calculating the Tick Range

Our goal for this guide is to create a [Buy Limit Order](https://docs.uniswap.org/concepts/protocol/range-orders#buy-limit-orders) that trades `token1` for `token0` when the Price of `token1` decreases by 5%.

To create our Position, we need to first decide the Tick Range that we want to provide liquidity in.

### Upper Tick

We [create a Pool](https://docs.uniswap.org/contracts/v4/quickstart/create-pool) that represents the v4 Pool we are interacting with and get the `token1Price`.
We won't need full tick data in this example.

```solidity
import {TickMath} from "v4-core/src/libraries/TickMath.sol";
import {Constants} from "./base/Constants.sol";
import {Config} from "./base/Config.sol";

uint24 public constant LP_FEE = 3000;
int24 public constant TICK_SPACING = 60;
uint256 public constant token1Amount = 1e6; //USDC

PoolKey memory pool = PoolKey({
    currency0: currency0, // imported from Config.sol
    currency1: currency1, // imported from Config.sol
    fee: LP_FEE,
    tickSpacing: TICK_SPACING,
    hooks: hookContract
});

// Get current pool sqrtPrice and tick
(uint160 sqrtPriceX96,,,) = POOLMANAGER.getSlot0(pool.toId()); //POOLMANAGER is imported from Constants.sol
int24 currentTick = TickMath.getTickAtSqrtPrice(sqrtPriceX96);
```

Next we decrease the `Price` by 5%. We create a new Price with a numerator 5% lower than our current Price:

```solidity
uint160 targetSqrtPriceX96 = uint160((uint256(sqrtPriceX96) * 974679) / 1e6); //Since we need to calculate 95% of the current sqrtprice
```

We have calculated our target Price but we still need to find the **nearest usable tick** to create our Position.

:::info
As Positions can only start and end at initializable Ticks of the Pool, so we can only create a Range Order to a Price that exactly matches an initializable Tick.
:::

We make use of the getTickAtSqrtPrice of TickMath contract to calculate the tick at a specific sqrtPrice value.

```solidity
import {TickMath} from "v4-core/src/libraries/TickMath.sol";

int24 targetTick = TickMath.getTickAtSqrtPrice(targetSqrtPriceX96);
int24 tickUpper = (targetTick / TICK_SPACING) * TICK_SPACING;
```

This nearest Tick will most likely not **exactly** match our Price target.

Depending on our personal preferences we can either err on the higher or lower side of our target by adding or subtracting the `tickSpacing` if the initializable Tick is lower or higher than the theoretically closest Tick.

### Lower Tick

We now find the lower Tick by subtracting the tickSpacing from the upper Tick:

```solidity
int24 tickLower = tickUpper - TICK_SPACING;
```

If the price difference is too low, the lower tick may be left of the current Tick of the Pool.
In that case we would not be able to provide single side liquidity.
We can either throw an Error or increase our Position by one Tick.

```solidity
if (tickLower <= currentTick) {
    tickLower += TICK_SPACING;
    tickUpper += TICK_SPACING;
}
```

We now have a lower and upper Tick for our Position, next we need to construct and mint it.

## Creating the Single Side Liquidity Position

We will first calculate the liquidity corresponding to our token1, tickLower and tickUpper.

```solidity
uint128 liquidity = LiquidityAmounts.getLiquidityForAmount1(
    TickMath.getSqrtPriceAtTick(tickLower),
    TickMath.getSqrtPriceAtTick(tickUpper),
    token1Amount
);
```

And then, we recalculate actual token1 necessary for that liquidity as we round up the liqudity to the nearest number and that could have changed the required token1.

```solidity
uint256 requiredToken1 = LiquidityAmounts.getAmount1ForLiquidity(
    TickMath.getSqrtPriceAtTick(tickLower),
    TickMath.getSqrtPriceAtTick(tickUpper),
    liquidity
);
```

Finally, we have to set up upper limits for Amount1 and Amount0 accounting for slippage.

```solidity
uint256 amount1Max = requiredToken1 + 1_000; // 0.001 USDC buffer
uint256 amount0Max = 1e14; // small ETH buffer
bytes memory hookData = new bytes(0);
```

### Minting the Position

We approve token transfers on behalf of msg.sender() by the PositionManager:

```Solidity
if (!currency1.isAddressZero()) {
    IERC20(Currency.unwrap(currency1)).approve(address(PERMIT2), type(uint256).max);
    PERMIT2.approve(Currency.unwrap(currency1), address(posm), type(uint160).max, type(uint48).max);
}
```

And now mint a new position using PositionManager's mint function:

```solidity
IPositionManager(address(posm)).mint(
    pool, tickLower, tickUpper, liquidity, amount0Max, amount1Max, msg.sender, block.timestamp + 60, hookData
);
```

We can find the Contract address on the official [Uniswap GitHub](https://docs.uniswap.org/contracts/v4/deployments).
For local development, the contract address is the same as the network we are forking from.
So if we are using a local fork of mainnet like described in the [Local development guide](https://docs.uniswap.org/sdk/v3/guides/local-development), the contract address would be the same as on mainnet.

Here is the full code example for these code snippets:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {CurrencyLibrary, Currency} from "v4-core/src/types/Currency.sol";
import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
import {LiquidityAmounts} from "v4-core/test/utils/LiquidityAmounts.sol";
import {TickMath} from "v4-core/src/libraries/TickMath.sol";
import {StateLibrary} from "v4-core/src/libraries/StateLibrary.sol";
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
import {EasyPosm} from "../test/utils/EasyPosm.sol";
import {Constants} from "./base/Constants.sol";
import {Config} from "./base/Config.sol";

import {IERC20} from "forge-std/interfaces/IERC20.sol";

contract AddSingleSidedLiquidity is Script, Constants, Config {
    using CurrencyLibrary for Currency;
    using StateLibrary for IPoolManager;
    using EasyPosm for IPositionManager;

    uint24 public constant LP_FEE = 3000;
    int24 public constant TICK_SPACING = 60;
    uint256 public constant token1Amount = 1e6;

    function run() external {
        PoolKey memory pool = PoolKey({
            currency0: currency0, 
            currency1: currency1,
            fee: LP_FEE,
            tickSpacing: TICK_SPACING,
            hooks: hookContract
        });

        // Get current pool sqrtPrice and tick
        (uint160 sqrtPriceX96,,,) = POOLMANAGER.getSlot0(pool.toId());
        int24 currentTick = TickMath.getTickAtSqrtPrice(sqrtPriceX96);

        //Calculating new target price
        uint160 targetSqrtPriceX96 = uint160((uint256(sqrtPriceX96) * 974679) / 1_000_000);
        int24 targetTick = TickMath.getTickAtSqrtPrice(targetSqrtPriceX96);
        int24 alignedTick = (targetTick / TICK_SPACING) * TICK_SPACING;

        int24 tickUpper = alignedTick;
        int24 tickLower = tickUpper - TICK_SPACING;

        if (tickLower <= currentTick) {
            tickLower += TICK_SPACING;
            tickUpper += TICK_SPACING;
        }
        
        // Calculate liquidity from token1 (USDC)
        uint128 liquidity = LiquidityAmounts.getLiquidityForAmount1(
            TickMath.getSqrtPriceAtTick(tickLower),
            TickMath.getSqrtPriceAtTick(tickUpper),
            token1Amount
        );

        uint256 requiredToken1 = LiquidityAmounts.getAmount1ForLiquidity(
        TickMath.getSqrtPriceAtTick(tickLower),
        TickMath.getSqrtPriceAtTick(tickUpper),
        liquidity
        );
        
        uint256 amount1Max = requiredToken1 + 1_000; // 0.001 USDC buffer
        uint256 amount0Max = 1e14; // small ETH buffer
        bytes memory hookData = new bytes(0);

        //Token Approval
        vm.startBroadcast();
        if (!currency1.isAddressZero()) {
            IERC20(Currency.unwrap(currency1)).approve(address(PERMIT2), type(uint256).max);
            PERMIT2.approve(Currency.unwrap(currency1), address(posm), type(uint160).max, type(uint48).max);
        }
        vm.stopBroadcast();

        //Minting a Position
        vm.startBroadcast();
        IPositionManager(address(posm)).mint(
            pool, tickLower, tickUpper, liquidity, amount0Max, amount1Max, msg.sender, block.timestamp + 60, hookData
        );
        vm.stopBroadcast();

    }
}
```

### Getting the tokenId

Now that we have minted a new position, we want to read the response to our `Mint` function call to get **the token id**.

We will need the tokenId to fetch the Position Info and use it to burn and take out position and can use the nextTokenId function from Position Manager contract.

```solidity
uint256 tokenId = posm.nextTokenId() - 1;
```

We have created our Range Order Position, now we need to monitor it and close the position when desired tick range is crossed and token1 increases in price value compare to token0.

## Closing the Limit Order

We have to call the modifyLiquidities function of Position Manager contract in order to burn a position and remove our token.

Uniswap v4 allows us to use Actions and encode multiple actions to be sent as params. For ex: 0x030x0e means burn a position and take the tokens.

And for that, we initialize the burnParams:
```solidity
bytes memory burnParams = abi.encode(
    tokenId,
    uint128(0),
    uint128(0),
    hookData
);
```

And then, initialize the takeParams:
```solidity
bytes memory takeParams = abi.encode(
    currency1,
    msg.sender,
    uint256(0)
);
```

## Burn and Take

We have to encode the actions and store the burn and take params in the params array:

```solidity
bytes memory actions = abi.encodePacked(
    bytes1(uint8(Actions.BURN_POSITION)),
    bytes1(uint8(Actions.TAKE))
);

bytes[] memory params = new bytes[](2);
params[0] = burnParams;
params[1] = takeParams;

bytes memory unlockData = abi.encode(actions, params);
```

The final step is to call the modifyLiquidities function in PositionManager:

```solidity
posm.modifyLiquidities(unlockData, block.timestamp + 60);
```

Full working code example for Burn and Take:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {IPositionManager} from "v4-periphery/src/interfaces/IPositionManager.sol";
import {Actions} from "v4-periphery/src/libraries/Actions.sol";
import {Currency} from "v4-core/src/types/Currency.sol";
import {Constants} from "./base/Constants.sol";
import {Config} from "./base/Config.sol";

contract BurnAndTake is Script, Constants, Config {
    function run() external {
        uint256 tokenId = posm.nextTokenId() - 1;

        bytes memory hookData = new bytes(0);

        bytes memory burnParams = abi.encode(
            tokenId,
            uint128(0),
            uint128(0),
            hookData
        );

        bytes memory takeParams = abi.encode(
            currency1,
            msg.sender,
            uint256(0)
        );

        // Clubbing Burn position and take actions
        bytes memory actions = abi.encodePacked(
            bytes1(uint8(Actions.BURN_POSITION)),
            bytes1(uint8(Actions.TAKE))
        );

        bytes[] memory params = new bytes[](2);
        params[0] = burnParams;
        params[1] = takeParams;

        bytes memory unlockData = abi.encode(actions, params);

        vm.startBroadcast();
        posm.modifyLiquidities(unlockData, block.timestamp + 60);
        vm.stopBroadcast();
    }
}

```

## Caveats

Executing a range order has certain limitations that may have become obvious during the course of this guide.

- If the price of the Pool drops below `tickUpper` while we already decided to withdraw our liquidity our order may fail and we either receive `token0`, `token0` and `token1` or our transaction fails depending on our exact implementation.
- Range Orders can only be created between initializable ticks and may not exactly represent our limit order Price-Target.
- Depending on the price ratio of the tokens in the Pool the minimum price difference to the current price may be significant.
- The tokens received are the average between the Price of `tickUpper` and `tickLower` of the Range order. This can be a significant difference for Pools with a tickCurrent far from 0, for example tokens with different decimals (WETH/ USDT, WETH/USDC). The example showcases this behaviour well with the default configuration.

## Next Steps

This guide showcases everything you need to implement Range Orders on your own, but only demonstrates creating a Buy Limit order in `token1` to `token0` direction.

Check out the [Take Profit Order](https://docs.uniswap.org/sdk/v3/guides/advanced/range-orders) from v3-sdk guides and try implementing it in v4.
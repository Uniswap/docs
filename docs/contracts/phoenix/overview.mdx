---
title: Overview
sidebar_position: 1
---
# Overview

Phoenix enables the permissionless collection and flexible conversion of any arbitrary fee sources, including but not limited to Uniswap protocol fees. The mechanism uses competitive economic incentives to ensure efficient fee collection while maintaining decentralized governance through immutable smart contracts.

## Why This Design?

- **Flexibility**: The system can adapt to new requirements without full redeployment
- **Security**: Core mechanisms remain immutable and secure
- **Governance**: DUNI retains control over important parameters
- **Efficiency**: Can optimize parameters (like UNI burn amounts) based on market conditions

## Architecture Overview

The Phoenix system consists of three core layers that work together on any chain where they are deployed:

### Asset Sink

The **Asset Sink** is an immutable smart contract that serves as the collection point for all fees. There is one Asset Sink deployed per chain.

#### Key Properties

- **Immutable**: Cannot be upgraded
- **Universal Collector**: Receives fees from all sources on the target chain
- **Single Privileged Role**: Only the `releaser` can withdraw assets
- **Atomic Operations**: Limits attack surface and simplifies searcher interaction

#### Governance

- **Privileged roles:**
  - `owner`: Can appoint a new `Releaser` contract which defines the economic criteria for accessing the assets held by the Asset Sink
- **Why This Matters**: If a better Releaser is developed, Governance can switch to it
- **Immutable Components**: The `release()` function logic that transfers full balances to recipients cannot be changed

### Fee Controllers

Fee Controllers are adapter contracts that channel fees from various sources into the Asset Sink. A Fee Controller contract is deployed for each fee source that requires one in order to configure fee collection mechanisms across different protocol versions and sources.

#### Key Properties

- **Source-Specific**: Each controller handles specific fee collection mechanisms
- **Permissionless Collection**: Anyone can trigger fee collection
- **Configurable**: Fee rates and parameters can be set as needed

*Some fee sources (e.g.Â Uniswap v2) push fees to a configurable destination directly,  and do not require a Fee Controller.*

#### Governance

Permissions and controls are specific to individual Fee Controller implementations. Fee Controllers are immutable and their core logic is not subject to change. Certain parameters related to that logic's execution may be adjustable to allow for system optimization.

### Releasers

Releasers are smart contracts that serve in the `releaser` role for Asset Sinks. They implement the business logic for converting collected fees into protocol value.

#### Key Properties

- **Economically Incentivized**: Releasers use competitive mechanisms to ensure efficiency
- **Permissionless**: Anyone can participate in the release process
- **Immutable**: A Releaser's economic logic is not subject to change

#### Governance

Permissions and controls are specific to individual Releaser implementations. Releasers are  immutable and their core logic is not subject to change. Certain parameters related to that logic's execution may be adjustable to allow for system optimization..

## Initial Deployment Configuration

Our first deployment will focus on Ethereum mainnet with Uniswap v3 fee collection and UNI token burning:

### V3FeeController

The V3FeeController is a Fee Controller contract. It should be configured to be the owner of the Uniswap V3 Factory. As owner, it can:

- enable new fee tiers
- set the owner of the factory
- adjust fees on v3 pools
- enable the collection of any fees from pools where they accrue

V3FeeController enables efficient batch updates of fee levels across many pools using Merkle roots.

#### Governance

- **Privileged roles (owned by Governance on deployment)**:
  - `owner`: Can appoint new `feeSetter`, enable new fee tiers, appoint new `V3FeeController`
  - `feeSetter`: Can define pool-level protocol fees, can update Merkle roots for fee configuration
- **Why This Matters**: Flexible fee management allows governance to optimize protocol revenue and respond to market conditions without redeploying contracts. Importantly, V3FeeController does not change Uniswap v3 pools' fee mechanism or parameters, it just adds flexibility in how those parameters can be adjusted.
- **Immutable Components**: The  `collect()` function logic,  `ASSET_SINK` and `FACTORY` addresses, and Merkle tree verification cannot be changed.

### Firepit Releaser

Firepit is a Releaser contract that implements a mechanism to burn UNI tokens with protocol fees.

#### Mechanism

1. Searcher pays fixed UNI amount to Firepit
2. Firepit releases Asset Sink contents to searcher
3. UNI tokens are burned (sent to `0xdead`), reducing total supply
4. Searcher profits from asset value exceeding UNI burn cost

This all happens atomically.

#### Governance

- **Privileged roles (owned by Governance on deployment)**:
  - `owner`: Can appoint the `thresholdSetter`
  - `thresholdSetter`:  Can define the `threshold` of UNI that must be burned in order to release assets
- **Why This Matters**: Configurable UNI burn thresholds allow governance to adjust the economic incentives based on market conditions and protocol needs
- **Immutable Components**: The UNI burn mechanism and asset release logic cannot be changed
- **Important Note**: The `thresholdSetter` can introduce value-loss to the protocol or integrators by modifying the `threshold` value during a pending release (see [Best Practices](./guides/best-practices))

## Real-World Example

As an economic example:

- Assume 100 UNI is the `threshold` amount for the Firepit Releaser.
- When the top *N* assets in the *Asset Sink* are worth slightly more than 100 UNI, **anyone** is incentivized to use the `Firepit.release()` contract to:
    1. Burn 100 UNI
    2. Withdraw the top *N* assets, *valued* at slightly more than 100 UNI
